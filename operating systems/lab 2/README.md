# Базовый трек. Лабораторная работа 2

## Задание

Для оптимизации работы с блочными устройствами в ОС существует кэш страниц с
данными, которыми мы производим операции чтения и записи на диск. Такой кэш
позволяет избежать высоких задержек при повторном доступе к данным, так как
операция будет выполнена с данными в RAM, а не на диске (вспомним [пирамиду памяти][memory-pyramid-csbasics]
на 35 слайде и [всё-всё][what-every-programmer-should-know-about-memory]).

В данной лабораторной работе необходимо реализовать блочный кэш в пространстве
пользователя в виде динамической библиотеки. Политику вытеснения страниц и
другие элементы задания необходимо получить у преподавателя.

При выполнении работы необходимо реализовать простой API для работы с файлами,
предоставляющий пользователю следующие возможности (по аналогии с системным API):

1. Открытие файла по заданному пути файла, доступного для чтения. Процедура
   возвращает некоторый хэндл на файл. Пример: `int vtpc_open(const char *path)`.

2. Закрытие файла по хэндлу. Пример: `int vtpc_close(int fd)`.

3. Чтение данных из файла.
   Пример: `ssize_t vtpc_read(int fd, void buf[.count], size_t count)`.

4. Запись данных в файл.
   Пример: `ssize_t vtpc_write(int fd, const void buf[.count], size_t count)`.

5. Перестановка позиции указателя на данные файла. Достаточно поддержать только
   абсолютные координаты.
   Пример: `​​​​​​​off_t vtpc_lseek(int fd, off_t offset, int whence)`.

6. Синхронизация данных из кэша с диском. Пример: `int vtpc_fsync(int fd)`.

Операции с диском разработанного блочного кеша должны производиться в обход
страничного кеша операционной системы.

В рамках проверки работоспособности разработанного блочного кэша необходимо
адаптировать указанную преподавателем программу-загрузчик из ЛР 1, добавив
использование кэша. Запустите программу и убедитесь, что она корректно работает.
Сравните производительность до и после.

Точкой входа в ваш модуль являются файлы `vtpc.h` и `vtpc.c`. Именно этот API
вызывается тестовым фреймворком, сравнивающим поведения вашего `vtpc` и `libc`.

## Ограничения

1. Программа (комплекс программ) должна быть реализован на языке C.

2. Если по выданному варианту задана политика вытеснения Optimal, то необходимо
   предоставить пользователю возможность подсказать page cache, когда будет
   совершен следующий доступ к данным. Это можно сделать либо добавив параметр в
   процедуры `read` и `write` (например, 
   `ssize_t vtpc_read(int fd, void buf[.count], size_t count, access_hint_t hint)`),
   либо добавив еще одну функцию в API (например, 
   `int vtpc_advice(int fd, off_t offset, access_hint_t hint)`). `access_hint_t`
   в данном случае – это абсолютное время или временной интервал, по которому
   разработанное API будет определять время последующего доступа к данным.

3. Запрещено использовать высокоуровневые абстракции над системными вызовами.

## Требования к отчету и защите

Отчет должен содержать:

1. титульный лист с указанием номера и названия ЛР, вашего ФИО, ФИО
   преподавателя практики, номера вашей группы, варианта ЛР;

2. текст задания в соответствии с вариантом;

3. краткий обзор кода;

4. данные о работе программы-нагрузчика до и после внедрения своего page cache;

5. заключение с анализом результатов и выводом.

## Описание вариантов

Вариант задания представляет собой название алгоритма вытеснения страниц из кеша, который изучается на лекции ([часть 3, 22 слайд][page-preemtion-algo-slides]), либо иной на усмотрение преподавателя. Например,

1. LRU -- Least Recently Used,
2. LFU -- Least Frequantly Used,
4. MRU -- Most Recently Used,
5. FIFO -- First In First Out,
6. NRU -- Not Recently Used,
7. Clock -- Часовой алгоритм,
9. Optimal (с подсказкой),
10. Random,
11. Second chance,
12. ARC,
13. 2Q,
14. LRU-K.

> [!NOTE]
> Это перечислены алгоритмы **вытеснения** страниц, но ведь страницы нужно ещё
> правильно **загружать** -- подумайте над тем, какую страницу следует взять в
> использование следующей и в какой момент.

[memory-pyramid-csbasics]: https://se.ifmo.ru/documents/10180/640663/%D0%9F%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F+%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9+2019+%D1%87%D0%B0%D1%81%D1%82%D1%8C+2.pdf/a89541ff-090d-47b4-8454-eb5d71afd207

[what-every-programmer-should-know-about-memory]: https://www.akkadia.org/drepper/cpumemory.pdf

[page-preemtion-algo-slides]: https://se.ifmo.ru/documents/10180/1505608/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5+%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B.+%D0%A7%D0%B0%D1%81%D1%82%D1%8C+3.pdf/188c34ff-f76c-1d42-b3cb-f9314b5898d8
