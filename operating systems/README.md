
# Операционные системы
## **О предмете**
Дисциплина предназначена для глубокого изучения архитектуры и построения современных операционных систем. Включает четыре раздела: общие сведения о опреационных системах и системных средствах, планирование и выполнение процессов, планирование и организация памяти, организация ввода-вывода

Продолжительность: 1 семестр.

## **Лабораторные работы**

### [**Лабораторная работа №1**](https://github.com/kihort-si/itmo/tree/main/operating%20systems/lab%201)
![C](https://github.com/kihort-si/itmo/blob/main/common/c.svg)

Вариант: `proc-fork, shell-seq, factorize, ema-sort-int`

#### Часть 1. Запуск программ

Необходимо реализовать собственную оболочку командной строки - shell. Shell
должен предоставлять пользователю возможность запускать программы на компьютере
с переданными аргументами командной строки и отображать время их выполнения
(расчитать как разность времени завершения и времени запуска).

#### Часть 2. Логические операторы

В разработанное приложение командной оболочки необходимо добавить поддержку
логических операторов (аналогичных операторам из Bash) согласно выданному варианту:

1. `&&` - логическое И (AND),
2. `||` - логическое ИЛИ (OR),
3. `;` - последовательное выполнение,
4. `&` - выполнение в фоне.

#### Часть 3. Анализ системы и мониторинг

Разработайте параметризируемую программу-нагрузчик, которая будет однопоточно нагружать подсистему ввода-вывода (IO). Она должна принимать на вход следующие параметры:

- `rw: read/write` - режим нагрузки: чтение или запись;
- `block_size: <number>` - размер блока в байтах, с которым производится чтение/запись;
- `block_count: <number>` - количество блоков;
- `file: <path string>` - имя файла, с которым происходит работа;
- `range: <number>-<number>` - границы в пределах файла, в которые должны
    осуществляться запись/чтение, значение по умолчанию, 0-0, означает, что доступен
    весь файл;
- `direct: on/off` - открывать файл с опцией O_DIRECT (в обход кэшей ОС) или нет;
- `type: sequence/random` - режим выбора следующего блока для записи/чтения
    последовательно или случайно;

Разработайте комплекс программ-нагрузчиков согласно выданному варианту.
Каждый нагрузчик должен принимать параметр, который определяет
количество повторений для алгоритма, указанного в задании, а также другие
вспомогательные параметры. Варианты программ рассчитаны так, чтобы по-разному
нагружать вычислительную подсистему (CPU) и подсистему ввода-вывода (IO) - это
необходимо учитывать при их реализации.  Разработанные программы еобходимо
скомпилировать без дополнительных опций оптимизации компилятора.

Проведите исследование поведения ОС во время исполнения разработанных
программ-нагрузчиков по следующему плану:

1. Перед запуском нагрузчика, попробуйте оценить время работы вашей программы
    или ее результаты (если по варианту вам досталось измерение чего либо) и
    обоснуйте свои предположения. 

2. Запустите программу-нагрузчик и зафиксируйте метрики ее работы с помощью
    инструментов для мониторинга и профилирования (см. лекции). Сравните полученные
    результаты с ожидаемыми. Объяснените наблюдаемое поведение. Продолжительность
    каждого запуска должна занимать достаточное для прекращения переходных
    процессов время, по крайней мере, минуту.

3. Определите количество одновременно запущенных процессов с программой-нагрузчиком,
    которое эффективно нагружает все ядра процессора в вашей системе. Как
    распределяются показатели времени USER%, SYS%, WAIT%, а также полное время
    выполнения нагрузчика, какое количество переключений контекста (вынужденных и
    невынужденных) происходит при этом? Подумайте над тем, как вы определяете
    эффективность.

4. Увеличьте количество нагрузчиков вдвое, втрое, вчетверо. Как изменились
    исследуемые показатели? Почему?

5. Объедините программы-нагрузчики в одну, реализованную при помощи потоков
    выполнения, чтобы один нагрузчик эффективно нагружал все ядра вашей системы. Как
    изменились показатели времени для того же объема вычислений? Запустите одну,
    две, три таких программы. Как изменились исследуемые показатели? Почему?

6. Скомпилируйте программу-нугрузчик с опцией агрессивной оптимизации. Как
    изменились исследуемые показатели? На сколько сократилось реальное время
    исполнения программы нагрузчика? Почему?

В процессе защиты вашей работы преподаватель будет просить вас запустить
программу-нагрузчик с различными комбинациями параметров и просить объяснить
результат.

#### Требования к реализации

1. Программа (комплекс программ) должна быть реализован на языке C.

2. Дочерние процессы должны быть созданы через указанные в варианте системные
    вызовы операционной системы, с обеспечением корректного запуска и завершения
    процессов. Запрещено использовать высокоуровневые абстракции над системными
    вызовами. Необходимо использовать, процедуры libc.

### [**Лабораторная работа №2**](https://github.com/kihort-si/itmo/tree/main/operating%20systems/lab%202)
![C](https://github.com/kihort-si/itmo/blob/main/common/c.svg)

Вариант: LRU

Для оптимизации работы с блочными устройствами в ОС существует кэш страниц с
данными, которыми мы производим операции чтения и записи на диск. Такой кэш
позволяет избежать высоких задержек при повторном доступе к данным, так как
операция будет выполнена с данными в RAM, а не на диске.

В данной лабораторной работе необходимо реализовать блочный кэш в пространстве
пользователя в виде динамической библиотеки. Политику вытеснения страниц и
другие элементы задания необходимо получить у преподавателя.

При выполнении работы необходимо реализовать простой API для работы с файлами,
предоставляющий пользователю следующие возможности (по аналогии с системным API):

1. Открытие файла по заданному пути файла, доступного для чтения. Процедура
   возвращает некоторый хэндл на файл. Пример: `int vtpc_open(const char *path)`.

2. Закрытие файла по хэндлу. Пример: `int vtpc_close(int fd)`.

3. Чтение данных из файла.
   Пример: `ssize_t vtpc_read(int fd, void buf[.count], size_t count)`.

4. Запись данных в файл.
   Пример: `ssize_t vtpc_write(int fd, const void buf[.count], size_t count)`.

5. Перестановка позиции указателя на данные файла. Достаточно поддержать только
   абсолютные координаты.
   Пример: `off_t vtpc_lseek(int fd, off_t offset, int whence)`.

6. Синхронизация данных из кэша с диском. Пример: `int vtpc_fsync(int fd)`.

Операции с диском разработанного блочного кеша должны производиться в обход
страничного кеша операционной системы.

В рамках проверки работоспособности разработанного блочного кэша необходимо
адаптировать указанную преподавателем программу-загрузчик из ЛР 1, добавив
использование кэша. Запустите программу и убедитесь, что она корректно работает.
Сравните производительность до и после.

Точкой входа в ваш модуль являются файлы `vtpc.h` и `vtpc.c`. Именно этот API
вызывается тестовым фреймворком, сравнивающим поведения вашего `vtpc` и `libc`.

#### Ограничения

1. Программа (комплекс программ) должна быть реализован на языке C.

2. Если по выданному варианту задана политика вытеснения Optimal, то необходимо
   предоставить пользователю возможность подсказать page cache, когда будет
   совершен следующий доступ к данным. Это можно сделать либо добавив параметр в
   процедуры `read` и `write` (например, 
   `ssize_t vtpc_read(int fd, void buf[.count], size_t count, access_hint_t hint)`),
   либо добавив еще одну функцию в API (например, 
   `int vtpc_advice(int fd, off_t offset, access_hint_t hint)`). `access_hint_t`
   в данном случае – это абсолютное время или временной интервал, по которому
   разработанное API будет определять время последующего доступа к данным.

3. Запрещено использовать высокоуровневые абстракции над системными вызовами.

