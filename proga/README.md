# Программирование

## **О предмете**

Курс включает в себя информацию об основных концепциях объектно-ориентированного программирования, синтаксисе языка Java, основных классов и интерфейсов языка.

Продолжительность: 2 семестра.

## **Лабораторные работы**

### Первый семестр

### [**Лабораторная работа №1**](https://github.com/kihort-si/itmo/tree/main/proga/lab1)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 2505

Написать программу на языке Java, выполняющую соответствующие варианту действия. Программа должна соответствовать следующим требованиям:
1.	Она должна быть упакована в исполняемый jar-архив.
2.	Выражение должно вычисляться в соответствии с правилами вычисления математических выражений (должен соблюдаться порядок выполнения действий и т.д.).
3.	Программа должна использовать математические функции из стандартной библиотеки Java.
4.	Результат вычисления выражения должен быть выведен в стандартный поток вывода в заданном формате.

Выполнение программы необходимо продемонстрировать на сервере helios.

1.	Создать одномерный массив c типа short. Заполнить его нечётными числами от 5 до 19 включительно в порядке убывания.
2.	Создать одномерный массив x типа float. Заполнить его 11-ю случайными числами в диапазоне от -7.0 до 8.0.
3.	Создать двумерный массив c размером 8x11. Вычислить его элементы по следующей формуле (где $x = x[j]$):

Если $c[i] = 17$, то $c[i][j] = 0.5/(sin⁡(sin⁡(x))+1)$

Если $c[i]∈ 5, 11, 15, 19$, то $c[i][j] = (0.5/(0.25+x^{1/3}))^3/(arctan(((x+0.5)/15)^2)+1)$

Для остальных значений $c[i]$: $c[i][j] = arcsin(cos⁡(arctan⁡(cos⁡((arctan⁡((x+0.5)/15))^{1/3}))))$

### [**Лабораторная работа №2**](https://github.com/kihort-si/itmo/tree/main/proga/lab2)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 2683

На основе базового класса Pokemon написать свои классы для заданных видов покемонов. Каждый вид покемона должен иметь один или два типа и стандартные базовые характеристики:

- очки здоровья (HP)
- атака (attack)
- защита (defense)
- специальная атака (special attack)
- специальная защита (special defense)
- скорость (speed)

Классы покемонов должны наследоваться в соответствии с цепочкой эволюции покемонов. На основе базовых классов PhysicalMove, SpecialMove и StatusMove реализовать свои классы для заданных видов атак.
Атака должна иметь стандартные тип, силу (power) и точность (accuracy). Должны быть реализованы стандартные эффекты атаки. Назначить каждому виду покемонов атаки в соответствии с вариантом. Уровень покемона выбирается минимально необходимым для всех реализованных атак.

Используя класс симуляции боя Battle, создать 2 команды покемонов (каждый покемон должен иметь имя) и запустить бой.

Покемоны:
- Corsola: Spike Cannon, Water Pulse, Bubble, Tackle;
- Pancham: Bulk Up, Tackle, Karate Chop;
- Pangoro: Bulk Up, Tackle, Karate Chop, Focus Blast;
- Flabebe: Psychic, Double Team;
- Floette: Psychic, Double Team, Razor Leaf;
- Florges: Psychic, Double Team, Razor Leaf, Magical Leaf.

### [**Лабораторная работа №3**](https://github.com/kihort-si/itmo/tree/main/proga/lab3)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 2725

Построить объектную модель по описанию предметной области. Доработать её в соответствии с принципами SOLID. Программа должна содержать как минимум два интерфейса и один абстрактный класс. В разработанных классах должны быть переопределены методы equals(), toString() и hashCode(). Программа должна содержать как минимум один перечисляемый тип (enum).

Описание предметной области:
```
"Сейчас же побегу за остальными, -- подумала она, но не побежала. -- Смелей! -- сказала она себе. -- Давай посмотрим, кто это!" И, вся дрожа, приблизилась к тому страшному, что лежало в воде. Это была большая женщина... Фрекен Снорк сделала несколько робких шагов и словно к земле приросла от изумления: женщина была деревянная! И еще она была удивительно красивая. Лицо ее безмятежно улыбалось, у нее были румяные щеки и губы, круглые, широко раскрытые голубые глаза. Волосы ее, тоже голубые, длинными крашеными локонами спадали на плечи...
```

### [**Лабораторная работа №4**](https://github.com/kihort-si/itmo/tree/main/proga/lab4)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 2725,5

Доработать программу из лабораторной работы #3, обновив реализацию объектной модели в соответствии с новой версией описания предметной области.

В программе должны быть реализованы 2 собственных класса исключений (checked и unchecked), а также обработка исключений этих классов.

В программу необходимо добавить использование локальных, анонимных и вложенных классов (static и non-static).

Описание предметной области:
```
Тем временем фрекен Снорк лазала по скалам на далеком мысу. Свою спаленную челку она прикрыла венком из морских лилий, и мечталось ей о такой находке, чтобы все ахнули от зависти и удивления. А когда наудивляются вдоволь, она отдаст ее Муми-троллю. (Разумеется, если находка не украшение.) Вздыхая, оглядела она пустынное побережье и вдруг остановилась как вкопанная, а сердце так и затрепетало у нее в груди. Там, в самом конце мыса... Нет, это было слишком страшно! Там кто-то лежал в воде и колотился головой о прибрежные камни! И этот кто-то был ужасно большой, в целых десять раз больше маленькой фрекен Снорк! "Сейчас же побегу за остальными, -- подумала она, но не побежала. -- Смелей! -- сказала она себе. -- Давай посмотрим, кто это!" И, вся дрожа, приблизилась к тому страшному, что лежало в воде. Это была большая женщина... Фрекен Снорк сделала несколько робких шагов и словно к земле приросла от изумления: женщина была деревянная! И еще она была удивительно красивая. Лицо ее безмятежно улыбалось, у нее были румяные щеки и губы, круглые, широко раскрытые голубые глаза. Волосы ее, тоже голубые, длинными крашеными локонами спадали на плечи... "Это королева", -- подумала фрекен Снорк. Руки прекрасной женщины были скрещены на груди, блиставшей золотыми цветами и цепями, а платье начиная от тонкой талии струилось мягкими красными складками. И все это было из крашеного дерева. Но что самое удивительное -- у женщины совсем не было спины
```

### Второй семестр

### [**Лабораторная работа №5**](https://github.com/kihort-si/itmo/tree/main/proga/lab5)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 40635

Реализовать консольное приложение, которое реализует управление коллекцией объектов в интерактивном режиме. В коллекции необходимо хранить объекты класса Person, описание которого приведено ниже.

Разработанная программа должна удовлетворять следующим требованиям:

- Класс, коллекцией экземпляров которого управляет программа, должен реализовывать сортировку по умолчанию.
- Все требования к полям класса (указанные в виде комментариев) должны быть выполнены.
- Для хранения необходимо использовать коллекцию типа java.util.LinkedHashSet
- При запуске приложения коллекция должна автоматически заполняться значениями из файла.
- Имя файла должно передаваться программе с помощью: переменная окружения.
- Данные должны храниться в файле в формате json
- Чтение данных из файла необходимо реализовать с помощью класса java.util.Scanner
- Запись данных в файл необходимо реализовать с помощью класса java.io.PrintWriter
- Все классы в программе должны быть задокументированы в формате javadoc.
- Программа должна корректно работать с неправильными данными (ошибки пользовательского ввода, отсутсвие прав доступа к файлу и т.п.).

В интерактивном режиме программа должна поддерживать выполнение следующих команд:

- **help** : вывести справку по доступным командам
- **info** : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)
- **show** : вывести в стандартный поток вывода все элементы коллекции в строковом представлении
- **add** ***{element}*** : добавить новый элемент в коллекцию
- **update id** ***{element}*** : обновить значение элемента коллекции, id которого равен заданному
- **remove_by_id** ***id*** : удалить элемент из коллекции по его id
- **clear** : очистить коллекцию
- **save** : сохранить коллекцию в файл
- **execute_script** ***file_name*** : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.
- **exit** : завершить программу (без сохранения в файл)
- **add_if_max** ***{element}*** : добавить новый элемент в коллекцию, если его значение превышает значение наибольшего элемента этой коллекции
- **add_if_min** ***{element}*** : добавить новый элемент в коллекцию, если его значение меньше, чем у наименьшего элемента этой коллекции
- **remove_lower** ***{element}*** : удалить из коллекции все элементы, меньшие, чем заданный
- **max_by_location** : вывести любой объект из коллекции, значение поля location которого является максимальным
- **count_greater_than_weight** ***weight*** : вывести количество элементов, значение поля weight которых больше заданного
- **filter_less_than_height** ***height*** : вывести элементы, значение поля height которых меньше заданного

Формат ввода команд:

- Все аргументы команды, являющиеся стандартными типами данных (примитивные типы, классы-оболочки, String, классы для хранения дат), должны вводиться в той же строке, что и имя команды.
- Все составные типы данных (объекты классов, хранящиеся в коллекции) должны вводиться по одному полю в строку.
- При вводе составных типов данных пользователю должно показываться приглашение к вводу, содержащее имя поля (например, "Введите дату рождения:")
- Если поле является enum'ом, то вводится имя одной из его констант (при этом список констант должен быть предварительно выведен).
- При некорректном пользовательском вводе (введена строка, не являющаяся именем константы в enum'е; введена строка вместо числа; введённое число не входит в указанные границы и т.п.) должно быть показано сообщение об ошибке и предложено повторить ввод поля.
- Для ввода значений null использовать пустую строку.
- Поля с комментарием "Значение этого поля должно генерироваться автоматически" не должны вводиться пользователем вручную при добавлении.

Описание хранимых в коллекции классов:

``` java
public class Person {
    private long id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
    private String name; //Поле не может быть null, Строка не может быть пустой
    private Coordinates coordinates; //Поле не может быть null
    private java.time.ZonedDateTime creationDate; //Поле не может быть null, Значение этого поля должно генерироваться автоматически
    private Double height; //Поле не может быть null, Значение поля должно быть больше 0
    private double weight; //Значение поля должно быть больше 0
    private Color eyeColor; //Поле не может быть null
    private Country nationality; //Поле может быть null
    private Location location; //Поле может быть null
}
public class Coordinates {
    private float x;
    private Float y; //Поле не может быть null
}
public class Location {
    private Float x; //Поле не может быть null
    private Long y; //Поле не может быть null
    private int z;
}
public enum Color {
    BLUE,
    YELLOW,
    ORANGE,
    WHITE;
}
public enum Country {
    FRANCE,
    THAILAND,
    SOUTH_KOREA;
}
```

### [**Лабораторная работа №6**](https://github.com/kihort-si/itmo/tree/main/proga/lab6)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)

Вариант № 262857

Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

Необходимо выполнить следующие требования:
- Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
- Объекты между клиентом и сервером должны передаваться в сериализованном виде.
- Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по имени
- Клиент должен корректно обрабатывать временную недоступность сервера.
- Обмен данными между клиентом и сервером должен осуществляться по протоколу TCP
- Для обмена данными на сервере необходимо использовать **сетевой канал**
- Для обмена данными на клиенте необходимо использовать **потоки ввода-вывода**
- Сетевые каналы должны использоваться в неблокирующем режиме.

Обязанности серверного приложения:

- Работа с файлом, хранящим коллекцию.
- Управление коллекцией объектов.
- Назначение автоматически генерируемых полей объектов в коллекции.
- Ожидание подключений и запросов от клиента.
- Обработка полученных запросов (команд).
- Сохранение коллекции в файл при завершении работы приложения.
- Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).

Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):
- Модуль приёма подключений.
- Модуль чтения запроса.
- Модуль обработки полученных команд.
- Модуль отправки ответов клиенту.

Сервер должен работать в **однопоточном** режиме.

Обязанности клиентского приложения:

- Чтение команд из консоли.
- Валидация вводимых данных.
- Сериализация введённой команды и её аргументов.
- Отправка полученной команды и её аргументов на сервер.
- Обработка ответа от сервера (вывод результата исполнения команды в консоль).
- Команду **save** из клиентского приложения необходимо убрать.
- Команда **exit** завершает работу клиентского приложения.

*Дополнительное задание*: Реализовать логирование различных этапов работы сервера (начало работы, получение нового подключения, получение нового запроса, отправка ответа и т.п.) с помощью **Logback**.

### [**Лабораторная работа №7**](https://github.com/kihort-si/itmo/tree/main/proga/lab7)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)
![PostgreSQL](https://github.com/kihort-si/itmo/blob/main/common/postgres.svg)

Вариант № 242655

Доработать программу из лабораторной работы №6 следующим образом:

1. Организовать хранение коллекции в реляционной СУБД (PostgresQL). Убрать хранение коллекции в файле.
2. Для генерации поля id использовать средства базы данных (sequence).
3. Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
4. Все команды получения данных должны работать с коллекцией в памяти, а не в БД
5. Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
6. Пароли при хранении хэшировать алгоритмом SHA-384
7. Запретить выполнение команд не авторизованным пользователям.
8. При хранении объектов сохранять информацию о пользователе, который создал этот объект.
9. Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие им.
10. Для идентификации пользователя отправлять логин и пароль с каждым запросом.

Необходимо реализовать многопоточную обработку запросов.
1. Для многопоточного чтения запросов использовать **Cached thread pool**
2. Для многопотчной обработки полученного запроса использовать **ForkJoinPool**
3. Для многопоточной отправки ответа использовать создание нового потока **(java.lang.Thread)**
4. Для синхронизации доступа к коллекции использовать потокобезопасные аналоги коллекции из **java.util.concurrent**

### [**Лабораторная работа №8**](https://github.com/kihort-si/itmo/tree/main/proga/lab8)
![Java](https://github.com/kihort-si/itmo/blob/main/common/java.svg)
![PostgreSQL](https://github.com/kihort-si/itmo/blob/main/common/postgres.svg)

Вариант № 2250

1. Интерфейс должен быть реализован с помощью библиотеки **Swing**
2. Графический интерфейс клиентской части должен поддерживать **русский, македонский, украинский и испанский (Пуэрто-Рико)** языки / локали. Должно обеспечиваться корректное отображение чисел, даты и времени в соответстии с локалью. Переключение языков должно происходить без перезапуска приложения. Локализованные ресурсы должны храниться в **файле свойств**.

Доработать программу из лабораторной работы №7 следующим образом:

Заменить консольный клиент на клиент с графическим интерфейсом пользователя (GUI). 

В функционал клиента должно входить:

1. Окно с авторизацией/регистрацией.
2. Отображение текущего пользователя.
3. Таблица, отображающая все объекты из коллекции
    + Каждое поле объекта - отдельная колонка таблицы.
    + Строки таблицы можно фильтровать/сортировать по значениям любой из колонок. Сортировку и фильтрацию значений столбцов реализовать с помощью Streams API.
4. Поддержка всех команд из предыдущих лабораторных работ.
5. Область, визуализирующую объекты коллекции
    + Объекты должны быть нарисованы с помощью графических примитивов с использованием Graphics, Canvas или аналогичных средств графической библиотеки.
    + При визуализации использовать данные о координатах и размерах объекта.
    + Объекты от разных пользователей должны быть нарисованы разными цветами.
    + При нажатии на объект должна выводиться информация об этом объекте.
    + При добавлении/удалении/изменении объекта, он должен **автоматически** появиться/исчезнуть/измениться на области как владельца, так и всех других клиентов. 
    + При отрисовке объекта должна воспроизводиться согласованная с преподавателем **анимация**.
6. Возможность редактирования отдельных полей любого из объектов (принадлежащего пользователю). Переход к редактированию объекта возможен из таблицы с общим списком объектов и из области с визуализацией объекта.
7. Возможность удаления выбранного объекта (даже если команды remove ранее не было).
Перед непосредственной разработкой приложения **необходимо** согласовать прототип интерфейса с преподавателем. Прототип интерфейса должен быть создан с помощью средства для построения прототипов интерфейсов (mockplus, draw.io, etc.)
