# Архитектура системы

## Общие положения

Глобально архитектуру системы можно разделить на 4 уровня:

- Фронтенд (веб интерфейс)
- Бэкенд (веб сервер на Raspberry Pi)
- Модули (универсальные модули на базе ESP8266)
- Устройства (испольнительные устройства и датчики)

Более нижний уровень является интерфейсом для более верхнего, внося очередной слой абстракции. Взаимодействие через один слой (не по порядку) исключается.

Далее в этом документе будет более подробно описана реализация каждого из уровней.

## Уровни

### Фронтенд

- Будет реализован в формате spa приложения на Rest + ts. 
- За разадачу статического контента будет отвечать веб сервер Nginx
- В качестве хостинга для фронтэнда также будет использованна Raspberry Pi
- Запросы к бэкэнду будет осуществлятся в рамках стандартного REST API по протоколу HTTP

### Бэкенд

- Будет реализован на Spring MVC + Boot
- При реализации будет использована старндартная слоистая архитектура
- Для обеспечения уровня хранения данных будет использована база данных SQLite
- Взаимодействие с фронтендом и модулями будет осуществлятеся в рамках стандартного REST API по протоколу HTTP

### Moдули

- Каждый модель будет представлять из себя законченное устройство в корпусе и состоять из следующих компонентов:
    - WEMOS D1 MINI на базе ESP8266
    - Модуль MOS транзиторов
    - Клемники
    - Модуль powerbank (котроль заряда + преобразовате на 5V)
    - Аккамулятор LiPo
- [Принципиальная схема модуля](/resource/module-scheme.pdf)
- Модули подчиняются rest запросам по [спецификации](https://se.ifmo.ru/~s409642/smart-greenhouse-api.html)

### Устройства

- Выделяется два типа внешних устройств: датчики и исполнительные устройства
- Управление исполнительными устройствами осуществляется чрез подключение их в разрыв цепи через транзистор
- При использовании исполнительных устройств 
- Датчики подразделяются на аналоговые и цифровые
- Список поддерживаемых устройств зафиксирован в прошивке модуля
- [Структурная схема подключения модулей и датчиков](/resource/modules-struct-scheme.png)

## Пример взаимодействия между уровнями

Сценарий: Backend → Модуль → Датчик температуры

1. Проверка доступности и идентификации модуля
    - Запрос:
        ```
        GET /info
        ```
    - Ответ:
        ```
        200 { "module-id": 1 }
        ```
    - Действия: сохранить/обновить модуль в БД (modules).

2. Обнаружение виртуальных портов и их ролей
    - Запрос:
        ```
        GET /ports
        ```
    - Ответ:
        ```
        200 {
          "ports": [
            { "id": 0, "type": 2 },
            { "id": 1, "type": 2 },
            { "id": 2, "type": 0 },
            { "id": 3, "type": 1 }
          ]
        }
        ```
    - Действия: сохранить карту портов

3. Обнаружение поддерживаемых драйверов
    - Запрос:
        ```
        GET /drivers
        ```
    - Ответ:
        ```
        200 {
          "drivers": [
            { "id": 2, "name": "DHT22", "type": 1 },
            ...
          ]
        }
        ```
    - Действия: сохранить каталог драйверов

4. Проверка/создание привязки драйвера к порту (bind)
    - Запрос (проверка):
        ```
        GET /ports/3/bind
        ```
    - Ответ (варианты):
        ```
        200 { "driverId": 2 }
        ```
        ```
        404  (привязка отсутствует)
        ```
    - Действия:
        - если 200 — перейти к чтению;
        - если 404 — создать привязку:
            - Запрос:
                ```
                PUT /ports/3/bind
                Content-Type: application/json

                { "driverId": 2 }
                ```
            - Ответ (варианты):
                ```
                200  (обновлено) / 201 (создано)
                ```
                ```
                409  (драйвер несовместим с типом порта)
                ```
                ```
                422  (драйвер или порт не найден)
                ```
            - Действия: при 200/201 — записать bind в БД (bindings); при 409/422 — завести инцидент/починить конфиг.

5. Чтение показаний с датчика
    - Запрос:
        ```
        GET /ports/3/control
        ```
    - Ответ (варианты):
        ```
        200 { "value": 23.6 }
        ```
        ```
        400  (порт не привязан к драйверу)
        ```
        ```
        405  (метод не поддерживается устройством)
        ```
    - Действия:
        - при 200 — сохранить измерение (measurements: moduleId, port, driverId, value, ts);
        - при 400 — вернуться к шагу 4 (создать bind);
        - при 405 — зафиксировать ошибку конфигурации (операция не для этого типа порта).
